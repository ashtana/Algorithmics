using namespace std; // видимость имён из std без std::
#include <complex>
#include <vector>
// int inch; декларирует что inch имеет тип int, т.е. inch - это целая переменная
// Объявление - это оператор, который вводит имя в программу. 
// Он специфицирует тип для именованной сущности:
// Тип определяет набор допустимых значений и операций над объектом
// Объект есть блок памяти, содержащий значение для некоторого типа
// Значение - это набор битов информации, интерпретируемый согласно типу
// Переменная - это именованнывй объект

// bool - логический тип, возможные значения true или false
// char - символьный тип, например 'a', 'г', '9'
// int - целое число, например 1, 11, 456 и т.п.
// double - число с плавающей точкой двойной точности, например 3.14 и 299793.0
// sizeof(<подставить название типа>) возвращает размер типа в байтах
// Арифметические операции
// x+y
// +x унарный плюс
// x-y
// -x унарный минус
// x*y умножить
// x/y поделить
// x%y остаток(модуль) для целых чисел

// Операции сравнения
// x==y  // равно
// x!=y  // не равно
// x<y
// x>y
// x<=y
// x>=y

void some_function() { // у функции нет возврата
    double d = 2.2; // инициализация double
    int i = 7; // инициализация int
    d = d+i; // присвоить d значение суммы
    i = d*i; // присвоть i значение d*i с усечением до целого
}

// два способа инициализации
double d1 = 2.3; // через знак =
double d2 {2.3}; // списковая форма

complex<double> z = 1; // комплексное число со скалярами двойной точности
complex<double> z2 {d1, d2};
complex<double> z3 = {1,2}; // необязательно с {...}
vector<int> v {1,2,3,4,5,6}; // вектор целых чисел

// Списковая форма предохранит от преобразований, теряющих информацию(сужающих преобразований)
int i1 = 7.2;
int i2 {7.2};  // ошибка: конверсия в целое из числа с плавающей точкой
int i3 = {7.2};  // тоже самое ошибка и знак = - избыточен

// Пользовательские типы (такие как string, vector, Matrix, Motor_controller или Orc_warrior)
// можно определить так, что станет возможной неявная инициализация

// При определении переменной нет необходимости явно специфицировать тип, если его можно вывести из
// инициализирующего значения:
auto b = true; // bool
auto z = sqrt(i1); // z имеет тип возврата sqrt(i1)

// Применяем auto, используем синтаксис со знаком =, 
// поскольку при этом отсутствует преобразование типов, которое может породить проблемы

// Специфические операции для изменения значения переменной
// x+=y -> x = x+y
// ++x -> инкремент x = x + 1
// x-=y -> x = x-y
// -x -> декремент x = x-1
// x*=y -> масштабирование x = x*y
// x/=y -> масштабирование x = x/y
// x%=y -> x = x%y
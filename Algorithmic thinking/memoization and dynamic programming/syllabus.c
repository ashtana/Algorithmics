#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Задача с платформы UV № 10910

/*
Условие
Для завершения учебного курса необходимо как минимум p оценок (p может быть любым целым числом). 
Студент полностью прошел n курсов. В сумме он заработал t оценок, 
но мы не знаем, сколько из них студент получил на каждом курсе. 
Отсюда вопрос: каким числом различных способов студент мог пройти все курсы?
В качестве примера предположим, что он прошел два курса, на которых заработал девять оценок. 
При этом для завершения каждого курса требуется получить не менее трех оценок. 
В этом случае есть четыре способа, которыми студент мог завершить все курсы:
  Три оценки на курсе 1 и шесть оценок на курсе 2.
  Четыре оценки на курсе 1 и пять оценок на курсе 2.
  Пять оценок на курсе 1 и четыре оценки на курсе 2.
  Шесть оценок на курсе 1 и три оценки на курсе 2.
*/

/*
Входные данные
Первая строка входных данных — это целое число k, указывающее количество тестовых примеров для выполнения. 
Каждый из k тестовых примеров представлен строкой, состоящей из трех целых чисел: n (количество завершенных курсов), 
t (общее число полученных оценок) и p (число оценок, необходимое для завершения каждого курса). 
Каждое значение n, t и p находится в диапазоне между 1 и 70.
Вот входные данные для рассмотренного выше примера:
1
2 9 3
*/

/*
Выходные данные 
Для каждого тестового примера следует вывести число способов, которыми можно 
распределить оценки так, чтобы студент завершил все курсы. 
Для примера выше выводом будет число 4.
Время на решение тестовых примеров — три секунды.
*/

// Решение. Мемоизация

#define SIZE 70

int solve(int n, int t, int p, int memo[SIZE + 1][SIZE + 1]) {
    int total, m;
    if (memo[n][t] != -1) {
        return memo[n][t];
    }
    if (n == 0 && t == 0) {
        return 1;
    }
    if (n == 0) {
        return 0;
    }
    total = 0;
    for (m = p; m <= t; m++) {
        total = total + solve(n - 1, t - m, p, memo);
    }
    memo[n][t] = total;
    return memo[n][t];
}

int main(void) {
    int k, i, x, y, n, t, p;
    int memo[SIZE + 1][SIZE + 1];
    scanf("%d", &k);
    for (i = 0; i < k; i++) {
        scanf("%d%d%d", &n, &t, &p);
        for (x = 0; x <= SIZE; x++) {
            for (y = 0; y <= SIZE; y++) {
                memo[x][y] = -1;
            }
        }
        printf("%d\n", solve(n, t, p, memo));
    }
    return 0;
}

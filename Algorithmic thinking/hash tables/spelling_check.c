#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Задача 3. Проверка орфографии: удаление буквы
// Это задача с Codeforces под номером 39J — «Проверка орфографии» (Spelling Check) 
// Ее можно легко найти через Google по запросу Codeforces 39J.

/* 
Условие
В задаче даются две строки (слова), первая из которых имеет на один символ больше, чем вторая. 
Цель — определить количество способов, которыми можно удалить один символ из первой строки, 
чтобы получить вторую строку. Например, существует только один способ получить из 
favour слово favor — удалить из первой строки u. Но есть три способа получить из 
abcdxxxef слово abcdxxef — удалить любой из символов x в первой строке.
Контекстом для задачи выступает система проверки правописания. 
Первой строкой может быть bizzarre (ошибочно набранное слово), а второй bizarre (его верный вариант). 
В этом случае есть два способа исправить ошибку — удалить одну из 
двух z в первом слове. Однако на деле задача является более общей и не связана 
исключительно со словами английского языка или ошибками правописания.

Решение должно укладываться в две секунды.
*/

/*
Входные данные
Входные данные - это два "слова", размещенные на двух строках. 
Каждое слово может содержать до миллиона символов.
*/

/*
Выходные данные
Если не существует способа удалить символ из первого слова для получения второго, выводом будет 0. 
В противном случае выводятся две строки:
  * на первой выводится количество способов, 
  которыми можно удалить символ из первого слова для получения второго;

  * на второй выводится разделенный пробелами список индексов тех символов первого слова, 
  которые можно удалить для получения второго слова. 

Задача требует начинать индексацию с 1, а не 0 (это не совсем удобно, но мы будем осторожны).

К примеру, для входных данных
abcdxxxef
abcdxxef
вывод будет таким:
3
5 6 7
Значения 5 6 7 — это индексы трех символов x в первом слове, 
так как отсчет идет от единицы, а не от нуля.
*/

#define SIZE 1000000

// Вычисление самого длинного общего префикса
int prefix_length(char s1[], char s2[]) {
    int i = 1;
    while (s1[i] == s2[i])
        i++;
    return i - 1;
}

// Вычисление самого длинного общего суффикса
int suffix_length(char s1[], char s2[], int len) {
    int i = len;
    while (i >= 2 && s1[i] == s2[i-1])
        i--;
    return len - i;
}

int main(void) {
    static char s1[SIZE + 2], s2[SIZE + 2]; // задаёт размер двухсимвольных массивов
    int len, prefix, suffix, total;
    gets(&s1[1]); // считываем первую строку
    gets(&s2[1]); // считываем вторую строку

    len = strlen(&s1[1]);
    prefix = prefix_length(s1, s2);
    suffix = suffix_length(s1, s2, len);
    // вычисление количества индексов, которые можно удалить из s1, чтобы получить s2
    total = (prefix + 1) - (len - suffix) + 1;
    if (total < 0) // Если число будет отрицательным, то мы устанавливаем для него значение 0
        total = 0;
    
    printf("%d\n", total);
    for (int i = 0; i < total; i++) { // выводятся искомые индексы
        printf("%d", i + len - suffix);
        if (i < total - 1)
            printf(" ");
        else
            printf("\n");
    }
    return 0;
}
/*
Задача 3. Качество жизни
Раcсмотрим задачу, в которой для определения допустимости решений потребуется динамическое программирование.
Это задача из чемпионата мира по программированию (IOI 2010).
Перед нами задача с платформы DMOJ под номером ioi10p3.
Условие
Город состоит из прямоугольной сетки кварталов. Каждый квартал обозначается координатами строки и столбца.
Всего есть _r_ строк, пронумерованных от 0 до _r_ – 1 сверху вниз, и _c_ столбцов, пронумерованных от 0 до _с_ – 1 слева направо.
Каждому квадрату присвоен индивидуальный ранг качества в диапазоне от 1 до _rc_.
К примеру, если дано семь строк и семь столбцов, то рангами кварталов будут числа между 1 и 49.
Пример схемы города дан в таблице ниже.

|   | 0  | 1  | 2  | 3  | 4  | 5  | 6  |
|---|----|----|----|----|----|----|----|
| 0 | 48 | 16 | 15 | 45 | 40 | 28 | 8  |
| 1 | 20 | 11 | 36 | 19 | 24 | 6  | 33 |
| 2 | 22 | 39 | 30 | 7  | 9  | 1  | 18 |
| 3 | 14 | 35 | 2  | 13 | 31 | 12 | 46 |
| 4 | 32 | 37 | 21 | 3  | 41 | 23 | 29 |
| 5 | 42 | 49 | 38 | 10 | 17 | 47 | 5  |
| 6 | 43 | 4  | 34 | 25 | 26 | 27 | 44 |

_Средний ранг качества прямоугольника_ — это ранг качества, относительно которого другие ранги делятся на две равные половины — с меньшими и большими значениями.
К примеру, рассмотрим прямоугольник размером пять строк на три столбца (5 × 3) в верхнем левом углу таблицы.
Он содержит 15 рангов качества: 48, 16, 15, 20, 11, 36, 22, 39, 30, 14, 35, 2, 32, 37 и 21.
Средним рангом здесь выступает 22, потому что семь чисел меньше 22, а другие семь — больше.

Нам будут даны целые числа h и w, указывающие высоту (количество строк) и ширину (количество столбцов) прямоугольников.
Задача — определить минимальный средний ранг качества любого прямоугольника с h строк и w столбцов.
Предположим, что h равна 5, а w равна 3. Тогда для города в таблицы средним рангом качества будет определено значение 13.
Прямоугольник со средним рангом качества 13 — этот тот, у которого верхний левый угол образует клетка (1, 3), а правый
нижний угол — (5, 5).
*/

/*
Входные данные
Все необходимые данные необходимо подставить в параметры функции. Вот функция:

int rectangle(int r, int c, int h, int w, board q)

Здесь `r` и `c` — количество строк и столбцов в схеме соответственно.
Аналогичным образом `h` и `w` — количество строк и столбцов в рассматриваемых прямоугольниках соответственно.
`h` будет не больше `r`, а `w` не больше `c`.
Также гарантируется, что `h` и `w` являются нечетными (произведение двух нечетных чисел — нечетное число, поэтому и `hw`,
количество кварталов в рассматриваемом прямоугольнике, будет нечетным.
Средний ранг качества в этом случае можно определить точно.
Если же у нас будет четное количество рангов качества, например четыре ранга — 2, 6, 4 и 5, то среднее значение придется выбирать между 4 и 5.
Автор задачи избавил нас от этого выбора).
Заключительный параметр `q` указывает ранги качества кварталов.
К примеру, `q[2][3]` определяет значение ранга квартала в строке 2, ряду 3.
Обратите внимание, что максимальное количество и строк, и столбцов в городе — 3001.
*/

/*
Выходные данные
Вернуть минимальный средний ранг качества.
Время на решение тестового примера — 10 секунд.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_ROWS 3001
#define MAX_COLS 3001

typedef int board[MAX_ROWS][MAX_COLS];

int can_make_quality(int quality, int r, int c, int h, int w, board q) {
  static int zero_one[MAX_ROWS][MAX_COLS];
  static int sum[MAX_ROWS + 1][MAX_COLS + 1];
  int i, j;
  int top_row, left_col, bottom_row, right_col;
  int total;

  for (i = 0; i < r; i++)
    for (j = 0; j < c; j++)
      if (q[i][j] <= quality)
        zero_one[i][j] = -1;
      else
        zero_one[i][j] = 1;

  for (i = 0; i <= c; i++)
    sum[0][i] = 0;
  for (i = 0; i <= r; i++)
    sum[i][0] = 0;
  for (i = 1; i <= r; i++)
    for (j = 1; j <= c; j++)
      sum[i][j] = zero_one[i-1][j-1] + sum[i-1][j] +
                  sum[i][j-1] - sum[i-1][j-1] ;

  for (top_row = 1; top_row <= r - h + 1; top_row++)
    for (left_col = 1; left_col <= c - w + 1; left_col++) {
      bottom_row = top_row + h - 1;
      right_col = left_col + w - 1;
      total = sum[bottom_row][right_col] - sum[top_row-1][right_col] -
              sum[bottom_row][left_col-1] + sum[top_row-1][left_col-1];
      if (total <= 0)
        return 1;
    }
  return 0;
}

int rectangle(int r, int c, int h, int w, board q) {
  int low, high, mid;
  low = 0;
  high = r * c + 1;
  while (high - low > 1) {
    mid = (low + high) / 2;
    if (can_make_quality(mid, r, c, h, w, q))
      high = mid;
    else
      low = mid;
  }
  return high;
}

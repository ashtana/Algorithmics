// Задача 1. Кормление муравьев
// Рассмотрим задачу с платформы DMOJ(dmoj.ca) под номером coci14c4p4.
/*
Условие
У Боби есть террариум в форме дерева. Каждое ребро этого дерева является трубкой, по которой стекает жидкость. Некоторые ребра образованы супертрубками,
по которым может протекать большее количество жидкости. В каждом листе (концевом узле) дерева находится один ручной муравей (согласен, что контекст 
фантастический, но сама задача очень интересная). У каждой трубки-ребра есть значение веса, указывающее процент протекающей по ней жидкости. 
К примеру, из узла n исходят три трубки, по которым стекает 20%, 50% и 30% жидкости от общего объема. Если в узел n поступает 20 литров жидкости, 
тогда по первой трубке стекает 20 × 0,2 = 4 литра, по второй 20 × 0,5 = 10 литров, по третьей 20 × 0,3 = 6 литров.
Каждая супертрубка может работать в стандартном или суперрежиме — в зависимости от выбора Боби. Если включен суперрежим, то количество протекающей 
жидкости возводится в квадрат. Боби заливает жидкость в корень дерева. Его цель — дать каждому муравью не меньше необходимого количества, 
минимизируя при этом заливаемый объем.

*/

/*
Входные данные
Входные данные содержат один тестовый пример, состоящий из следующих строк:
- целого числа n, задающего количество узлов в дереве. Значение n находится между 1 и 1000. Узлы дерева пронумерованы от 1 до n, а корнем является узел 1;
- (n – 1) строк, используемых для построения дерева. Каждая содержит данные об одной трубке и состоит из четырех целых чисел: номеров двух узлов, соединяемых этой трубкой, ее процентного значения (между 1 и 100) и указания о возможности суперрежима (0 означает отсутствие, 1 — наличие); 
- строки, содержащей n целых чисел, по одному для каждого узла, сообщающих количество литров, необходимых муравью в этом узле. Каждому муравью требуется от 1 до 10 литров жидкости. Все не концевые узлы (в которых нет муравья) содержат значение –1.

Вот входные данные, которые сгенерируют образец террариума с рисунка выше:
6
1 2 20 0
1 3 50 0
1 4 30 1
4 5 50 0
4 6 50 0
-1 2 9 -1 7 8

Обратите внимание, что первая строка (число 6) указывает количество узлов дерева, а не количество строк, его выстраивающих. 
Число строк, создающих дерево(в данном случае пять), всегда будет на единицу меньше числа узлов.
*/

/*
Выходные данные
Требуется вывести минимальное количество литров жидкости, которое Боби должен залить в корневой узел дерева, чтобы напоить всех муравьев. 
Точность должна быть выше четырех цифр после запятой. Верное значение не будет превышать двух миллиардов.
Время на решение тестового примера — 2,5 секунды.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_NODES 1000
#define HIGHEST 2000000000

typedef struct edge {
  int to_node, percentage, superpipe;
  struct edge *next;
} edge;

int can_feed(int node, double liquid, edge *adj_list[], int liquid_needed[]) {
  edge *e;
  int ok;
  double down_pipe;
  if (liquid_needed[node] != -1)
    return liquid >= liquid_needed[node];
  e = adj_list[node];
  ok = 1;
  while (e && ok) {
    down_pipe = liquid * e->percentage / 100;
    if (e->superpipe)
      down_pipe = down_pipe * down_pipe;
    if (!can_feed(e->to_node, down_pipe, adj_list, liquid_needed))
      ok = 0;
    e = e->next;
  }
  return ok;
}

void solve(edge *adj_list[], int liquid_needed[]) {
  double low, high, mid;
  low = 0;
  high = HIGHEST;
  while (high - low > 0.00001) {
    mid = (low + high) / 2;
    if (can_feed(1, mid, adj_list, liquid_needed))
      high = mid;
    else
      low = mid;
  }
  printf("%.4lf\n", high);
}

int main(void) {
  static edge *adj_list[MAX_NODES + 1] = {NULL};
  static int liquid_needed[MAX_NODES + 1];
  int num_nodes, i;
  int from_node, to_node, percentage, superpipe;
  edge *e;
  scanf("%d", &num_nodes);

  for (i = 0; i < num_nodes - 1; i++) {
    scanf("%d%d%d%d", &from_node, &to_node, &percentage, &superpipe);
    e = malloc(sizeof(edge));
    if (e == NULL) {
      fprintf(stderr, "malloc error\n");
      exit(1);
    }
    e->to_node = to_node;
    e->percentage = percentage;
    e->superpipe = superpipe;
    e->next = adj_list[from_node];
    adj_list[from_node] = e;
  }

  for (i = 1; i <= num_nodes; i++)
    scanf("%d", &liquid_needed[i]);
  solve(adj_list, liquid_needed);
  return 0;
}

/*
Задача 4. Двери пещеры
Ее особенность состоит в том, что двоичный поиск будет использоваться не для нахождения оптимального решения, 
а для быстрого выделения нужного элемента.
Рассмотрим задачу с платформы DMOJ под номером ioi13p4.
*/

/*
Условие
Вы стоите перед входом в длинную узкую пещеру, через которую необходимо пробраться и достичь выхода.
На пути нужно пройти через n дверей: первая — это дверь 0, вторая — дверь 1 и т. д.
Каждая дверь может быть открыта либо закрыта. 
Через открытые двери можно пройти, через закрытые — нельзя. 
Таким образом, если двери 0 и 1 открыты, а дверь 2 закрыта, то можно пройти только до двери 2, 
причем вы не видите состояния следующих за ней дверей.
У входа в пещеру установлена панель с n рычагов. 
Как и двери, рычаги пронумерованы, начиная с 0. Каждый из них может быть в верхнем (0) или нижнем (1) положении.
При этом каждый рычаг связан с одной дверью, определяя, закрыта она или открыта.
Если рычаг установлен в правильное положение, то соответствующая дверь открыта.
В противном случае эта дверь закрыта. Вам не известны ни связь рычагов с дверьми, ни правильные положения рычагов. 
К примеру, возможно, что рычаг 0 связан с дверью 5 и для ее открывания должен находиться в нижнем положении, 
а рычаг 1 связан с дверью 0 и для ее открывания должен находиться в верхнем положении.
Можно устанавливать рычаги в желаемое положение, а затем проходить в пещеру для определения первой закрытой двери и возвращаться. 
При этом запаса сил вам хватит максимум на 70 000 таких циклов. 
Цель — определить верное положение(0 или 1) каждого рычага и связанную с ним дверь.
Нужно написать следующую функцию: `exploreCave(n)`.
Здесь `n` является количеством дверей и рычагов (от 1 до 5000). 
Для реализации этой функции нужно будет вызвать две функции, предоставленные судьей. 
Они будут описаны далее.
*/

/*
Входные данные
Из стандартного ввода мы ничего не считываем. 
Единственный способ узнать исходные данные — это вызвать предоставленную судьей функцию tryCombination.
Вот ее сигнатура: `tryCombination(switch_positions)`.
Параметр switch_positions является массивом с длиной `n` целых чисел, указывающим положение (0 или 1) каждого рычага. 
То есть `switch_positions[0]` определяет положение рычага 0, `switch_positions[1]` — положение рычага 1 и т. д. 
Функция `tryCombination` симулирует ситуацию, в которой мы устанавливаем рычаги в `switch_positions` и проходим по пещере до первой закрытой двери. 
Она возвращает номер первой закрытой двери либо -1, если все двери открыты.
*/

/*
Выходные данные
В стандартный вывод запись не производится. Вместо этого мы отправляем ответ через вызов функции answer, также предоставленной судейским ресурсом. 
Вот ее сигнатура: `answer(switch_positions, door_for_switch)`.
У нас есть только одна попытка: при вызове `answer` наша программа уничтожается, так что правильный ответ следует отправлять с первого раза. 
Параметр `switch_positions` — массив, содержащий предлагаемые нами положения рычагов в том же формате, что и `tryCombination`. 
Параметр `door_for_switch` содержит предлагаемые нами связи между рычагами и дверьми: `door_for_switch[0]` указывает дверь, связанную с рычагом 0, 
`door_for_switch[1]` указывает дверь, связанную с рычагом 1, и т. д.
В данном случае ограничено не время, а количество вызовов `tryCombination`, которых допускается сделать на более 70 000. 
В случае превышения этого значения программа завершается.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void set_a_switch(int door, int switch_positions[],
                  int door_for_switch[], int n) {
  int i, result;
  int low = 0, high = n-1, mid;

  for (i = 0; i < n; i++)
    if (door_for_switch[i] == -1)
      switch_positions[i] = 0;

  result = tryCombination(switch_positions);
  if (result != door) {
    for (i = 0; i < n; i++)
      if (door_for_switch[i] == -1)
        switch_positions[i] = 1;
  }

  while (low != high) {
    mid = (low + high) / 2;
    for (i = low; i <= mid; i++)
      if (door_for_switch[i] == -1)
        switch_positions[i] = 1 - switch_positions[i];
    result = tryCombination(switch_positions);
    if (result != door) {
      high = mid;
      for (i = low; i <= mid; i++)
        if (door_for_switch[i] == -1)
          switch_positions[i] = 1 - switch_positions[i];
    }
    else
      low = mid + 1;
  }
  door_for_switch[low] = door;
  switch_positions[low] = 1 - switch_positions[low];
}

void exploreCave(int n) {
  int switch_positions[n], door_for_switch[n];
  int i;
  for (i = 0; i < n; i++)
    door_for_switch[i] = -1;

  for (i = 0; i < n; i++)
    set_a_switch(i, switch_positions, door_for_switch, n);
  answer(switch_positions, door_for_switch);
}
